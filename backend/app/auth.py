import os\nfrom datetime import datetime, timedelta, timezone\nfrom typing import Optional\n\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jose import JWTError, jwt\nfrom passlib.context import CryptContext\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy import select\n\nfrom .database import get_db\nfrom . import models\n\n# Config\nSECRET_KEY = os.getenv(\"SECRET_KEY\", \"dev-secret-key-change-me\")\nALGORITHM = os.getenv(\"JWT_ALGORITHM\", \"HS256\")\nACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv(\"ACCESS_TOKEN_EXPIRE_MINUTES\", \"480\"))  # 8h\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"], deprecated=\"auto\")\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/auth/login\")\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\ndef create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:\n    to_encode = data.copy()\n    expire = datetime.now(timezone.utc) + (expires_delta or timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES))\n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)\n    return encoded_jwt\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme), db: Session = Depends(get_db)) -> models.User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail=\"Could not validate credentials\",\n        headers={\"WWW-Authenticate\": \"Bearer\"},\n    )\n    try:\n        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n\n    user = db.execute(select(models.User).where(models.User.username == username)).scalar_one_or_none()\n    if user is None:\n        raise credentials_exception\n    if not user.is_active:\n        raise HTTPException(status_code=400, detail=\"Inactive user\")\n    return user\n\n\nasync def require_admin(user: models.User = Depends(get_current_user)) -> models.User:\n    if not user.is_admin:\n        raise HTTPException(status_code=403, detail=\"Admin privileges required\")\n    return user\n